// ============================================
// OPTIMISATION HOME.TSX - Composants SVG Mémorisés
// ============================================
// 
// Instructions :
// 1. Copier les composants SVG mémorisés ci-dessous AVANT le composant Home
// 2. Remplacer renderIcon par la version optimisée
// 3. Mémoriser handleLogoPress et handleNodePress
//
// Gain estimé : ~300ms

// ========== COMPOSANTS SVG MÉMORISÉS ==========

import React, { useState, useEffect, useMemo, useCallback } from 'react';
// ... existing imports ...

// Mémoriser les composants SVG (à placer AVANT le composant Home)
const BaytAnNurIcon = React.memo(({ size }: { size: number }) => (
  <Svg width={size} height={size} viewBox="0 0 32 32">
    <Rect x="14" y="8" width="4" height="12" stroke="white" strokeWidth="2" fill="none" rx="1" />
    <Line x1="16" y1="8" x2="16" y2="6" stroke="white" strokeWidth="2" strokeLinecap="round" />
    <Path d="M16 6 Q15 4 16 2 Q17 4 16 6" stroke="white" strokeWidth="2" fill="white" fillOpacity="0.3" />
    <Ellipse cx="16" cy="20" rx="3" ry="1.5" stroke="white" strokeWidth="2" fill="none" />
    {[...Array(6)].map((_, i) => {
      const angle = (i * 60) * (Math.PI / 180);
      const x1 = 16 + 10 * Math.cos(angle);
      const y1 = 14 + 10 * Math.sin(angle);
      const x2 = 16 + 12 * Math.cos(angle);
      const y2 = 14 + 12 * Math.sin(angle);
      return <Line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke="white" strokeWidth="1" opacity="0.6" />;
    })}
  </Svg>
));

const SabilanurIcon = React.memo(({ size }: { size: number }) => (
  <Svg width={size} height={size} viewBox="0 0 32 32">
    <Rect x="8" y="8" width="16" height="16" stroke="white" strokeWidth="2" fill="none" />
    <Rect x="12" y="12" width="8" height="8" stroke="white" strokeWidth="2" fill="none" />
  </Svg>
));

const UmmAynaIcon = React.memo(({ size }: { size: number }) => (
  <Svg width={size} height={size} viewBox="0 0 32 32">
    <Circle cx="12" cy="12" r="4" stroke="white" strokeWidth="2" fill="none" />
    <Circle cx="20" cy="12" r="4" stroke="white" strokeWidth="2" fill="none" />
    <Path d="M8 22C8 19 10 17 12 17C14 17 16 19 16 22" stroke="white" strokeWidth="2" fill="none" />
    <Path d="M16 22C16 19 18 17 20 17C22 17 24 19 24 22" stroke="white" strokeWidth="2" fill="none" />
  </Svg>
));

const NurShifaIcon = React.memo(({ size }: { size: number }) => (
  <Svg width={size} height={size} viewBox="0 0 32 32">
    <Path d="M16 6 L20 14 L28 16 L20 18 L16 26 L12 18 L4 16 L12 14 Z" stroke="white" strokeWidth="2" fill="none" />
  </Svg>
));

const DairatIcon = React.memo(({ size }: { size: number }) => (
  <Svg width={size} height={size} viewBox="0 0 32 32">
    <Circle cx="16" cy="16" r="10" stroke="white" strokeWidth="2" fill="none" />
    <Circle cx="16" cy="16" r="6" stroke="white" strokeWidth="2" fill="none" />
    <Circle cx="16" cy="16" r="2" fill="white" />
  </Svg>
));

// SalatIcon optimisé avec useMemo
const SalatIcon = React.memo(({ size, angle }: { size: number; angle: number }) => {
  const { user } = useUser();
  const currentTheme = getTheme(user?.theme || 'default');
  
  const rotation = useSharedValue(angle);
  
  useEffect(() => {
    rotation.value = withTiming(angle, { duration: 100 });
  }, [angle, rotation]);
  
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ rotate: `${rotation.value}deg` }],
    };
  });

  return (
    <View style={{ width: size, height: size, justifyContent: 'center', alignItems: 'center' }}>
      <Svg width={size} height={size} viewBox="0 0 24 24">
        <Circle cx="12" cy="12" r="10" stroke="white" opacity="0.2" strokeWidth="2" fill="none" />
      </Svg>
      <Animated.View style={[{ position: 'absolute', width: size, height: size, justifyContent: 'center', alignItems: 'center' }, animatedStyle]}>
        <Svg width={size} height={size} viewBox="0 0 24 24">
          <G x="12" y="12">
            <Path d="M0 -8 L2 0 L0 -2 L-2 0 Z" fill={currentTheme.colors.accent} />
          </G>
        </Svg>
      </Animated.View>
    </View>
  );
}, (prevProps, nextProps) => {
  // Comparaison personnalisée pour éviter les re-renders inutiles
  return prevProps.size === nextProps.size && 
         Math.abs(prevProps.angle - nextProps.angle) < 1; // Tolérance de 1 degré
});

// ========== DANS LE COMPOSANT HOME ==========

export function Home() {
  // ... existing code ...

  // ✅ OPTIMISÉ : Mémoriser handleLogoPress
  const handleLogoPress = useCallback(() => {
    navigation.navigate('AsmaUlHusna' as never);
  }, [navigation]);

  // ✅ OPTIMISÉ : Mémoriser handleNodePress
  const handleNodePress = useCallback((node: typeof nodes[0]) => {
    if (node.action === 'modal') {
      setShowPrayerModal(true);
    } else if (node.route) {
      InteractionManager.runAfterInteractions(() => {
        navigation.navigate(node.route as never);
      });
    }
  }, [navigation]);

  // ✅ OPTIMISÉ : Mémoriser renderIcon
  const renderIcon = useCallback((iconType: string, size: number) => {
    switch (iconType) {
      case 'baytnur':
        return <BaytAnNurIcon size={size} />;
      case 'sabilanur':
        return <SabilanurIcon size={size} />;
      case 'ummayna':
        return <UmmAynaIcon size={size} />;
      case 'nurshifa':
        return <NurShifaIcon size={size} />;
      case 'salat':
        return <SalatIcon size={size} angle={sensorQibla ?? qibla ?? 0} />;
      case 'dairat':
        return <DairatIcon size={size} />;
      default:
        return null;
    }
  }, [sensorQibla, qibla]);

  // ✅ OPTIMISÉ : Dans le map des nodes, utiliser handleNodePress
  {nodes.map((node, index) => {
    const { x, y } = getPosition(node.angle);
    // ... existing code ...
    
    return (
      <View key={node.name} /* ... */>
        <TouchableOpacity
          onPress={() => handleNodePress(node)} // ✅ Utiliser le callback mémorisé
          // ... existing code ...
        >
          {renderIcon(node.icon, buttonSize * 0.5)}
        </TouchableOpacity>
      </View>
    );
  })}

  // ✅ OPTIMISÉ : Image avec priority et recyclingKey
  <Image
    source={require('../../assets/images/ayna.png')}
    style={styles.logo}
    contentFit="contain"
    cachePolicy="memory-disk"
    transition={200}
    priority="high"
    recyclingKey="ayna-logo"
  />

  // ... rest of the code ...
}








